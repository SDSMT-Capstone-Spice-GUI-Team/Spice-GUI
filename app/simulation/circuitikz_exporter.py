"""
simulation/circuitikz_exporter.py

Generates CircuiTikZ LaTeX code from circuit model data.
Pure Python — no Qt dependencies.
"""

# CircuiTikZ component names keyed by Spice-GUI component type
CIRCUITIKZ_BIPOLES = {
    "Resistor": "R",
    "Capacitor": "C",
    "Inductor": "L",
    "Voltage Source": "V",
    "Current Source": "I",
    "Waveform Source": "sV",
    "Diode": "D",
    "LED": "led",
    "Zener Diode": "zD",
    "VC Switch": "closing switch",
    "VCVS": "american controlled voltage source",
    "VCCS": "american controlled current source",
    "CCVS": "american controlled voltage source",
    "CCCS": "american controlled current source",
}

CIRCUITIKZ_TRIPOLES = {
    "BJT NPN": "npn",
    "BJT PNP": "pnp",
    "MOSFET NMOS": "nmos",
    "MOSFET PMOS": "pmos",
    "Op-Amp": "op amp",
}

# Terminal name suffixes for tripole node anchors
TRIPOLE_ANCHORS = {
    "BJT NPN": ["C", "B", "E"],  # collector, base, emitter
    "BJT PNP": ["C", "B", "E"],
    "MOSFET NMOS": ["D", "G", "S"],  # drain, gate, source
    "MOSFET PMOS": ["D", "G", "S"],
    "Op-Amp": ["-", "+", "out"],  # inverting, non-inverting, output
}

# Default pixels-per-TikZ-unit (grid spacing = 20px)
DEFAULT_SCALE = 20.0


def _fmt(v):
    """Format a float coordinate, suppressing trailing zeros."""
    if v == int(v):
        return str(int(v))
    return f"{v:.2f}".rstrip("0").rstrip(".")


def _coord(x, y):
    """Format a TikZ coordinate pair."""
    return f"({_fmt(x)}, {_fmt(y)})"


def _escape_latex(s):
    """Escape special LaTeX characters in a string."""
    for ch in ("\\", "&", "%", "$", "#", "_", "{", "}"):
        s = s.replace(ch, "\\" + ch)
    return s


def _transform_coords(components, scale):
    """Compute origin offset and return a transform function.

    Maps Spice-GUI pixel coordinates to TikZ units:
    - Divides by *scale* (default 20 → 1 grid = 1 TikZ unit)
    - Flips Y axis (Qt Y-down → TikZ Y-up)
    - Translates so the top-left component sits near the origin
    """
    if not components:
        return lambda x, y: (0.0, 0.0)

    all_positions = [c.position for c in components.values()]
    min_x = min(p[0] for p in all_positions)
    max_y = max(p[1] for p in all_positions)

    def transform(x, y):
        tx = (x - min_x) / scale
        ty = (max_y - y) / scale
        return (round(tx, 2), round(ty, 2))

    return transform


def _component_label_opts(comp, include_id=True, include_value=True):
    """Build the CircuiTikZ label options string for a bipole."""
    parts = []
    if include_id:
        parts.append(f"l=${_escape_latex(comp.component_id)}$")
    if (
        include_value
        and comp.value
        and comp.component_type
        not in (
            "Ground",
            "Op-Amp",
            "BJT NPN",
            "BJT PNP",
            "MOSFET NMOS",
            "MOSFET PMOS",
        )
    ):
        parts.append(f"a={{{_escape_latex(comp.value)}}}")
    return ", ".join(parts)


def generate(
    components,
    wires,
    nodes,
    terminal_to_node,
    standalone=True,
    circuit_name="",
    scale=DEFAULT_SCALE,
    include_ids=True,
    include_values=True,
    include_net_labels=True,
    style="american",
):
    """Generate CircuiTikZ LaTeX code from circuit model data.

    Args:
        components: dict[str, ComponentData]
        wires: list[WireData]
        nodes: list[NodeData]
        terminal_to_node: dict[tuple[str,int], NodeData]
        standalone: If True, wrap in a standalone document. If False,
                    emit only the circuitikz environment.
        circuit_name: Optional name for the header comment.
        scale: Pixels per TikZ unit (default 20).
        include_ids: Show component IDs as labels.
        include_values: Show component values as annotations.
        include_net_labels: Show custom net labels as node annotations.
        style: "american" (default) or "european".

    Returns:
        str: LaTeX source code.
    """
    transform = _transform_coords(components, scale)
    lines = []

    # --- Preamble ---
    if standalone:
        lines.append("% Generated by Spice-GUI")
        if circuit_name:
            lines.append(f"% Circuit: {circuit_name}")
        lines.append(r"\documentclass[border=10pt]{standalone}")
        lines.append(r"\usepackage[siunitx]{circuitikz}")
        if style == "european":
            lines.append(r"\ctikzset{european}")
        lines.append(r"\begin{document}")

    lines.append(r"\begin{circuitikz}")

    # --- Bipole components ---
    lines.append("  % Components")
    for comp in sorted(components.values(), key=lambda c: c.component_id):
        ctype = comp.component_type
        if ctype == "Ground":
            continue  # handled separately

        tikz_name = CIRCUITIKZ_BIPOLES.get(ctype)
        if tikz_name is not None:
            _emit_bipole(lines, comp, tikz_name, transform, include_ids, include_values)
            continue

        tikz_name = CIRCUITIKZ_TRIPOLES.get(ctype)
        if tikz_name is not None:
            _emit_tripole(lines, comp, tikz_name, transform, include_ids)
            continue

    # --- Ground symbols ---
    ground_comps = [c for c in components.values() if c.component_type == "Ground"]
    if ground_comps:
        lines.append("  % Ground")
        for gnd in sorted(ground_comps, key=lambda c: c.component_id):
            terminals = gnd.get_terminal_positions()
            if terminals:
                gx, gy = transform(*terminals[0])
                lines.append(f"  \\node[ground] at {_coord(gx, gy)} {{}};")

    # --- Wires (connections not covered by components) ---
    wire_lines = _emit_wires(wires, components, transform)
    if wire_lines:
        lines.append("  % Wires")
        lines.extend(wire_lines)

    # --- Net labels ---
    if include_net_labels:
        label_lines = _emit_net_labels(nodes, terminal_to_node, components, transform)
        if label_lines:
            lines.append("  % Net labels")
            lines.extend(label_lines)

    lines.append(r"\end{circuitikz}")

    if standalone:
        lines.append(r"\end{document}")

    return "\n".join(lines) + "\n"


def _emit_bipole(lines, comp, tikz_name, transform, include_ids, include_values):
    r"""Emit a \draw ... to[component] ... line for a 2-terminal (or 4-terminal) component."""
    terminals = comp.get_terminal_positions()

    if comp.get_terminal_count() == 4:
        # 4-terminal devices (VCVS, VCCS, CCVS, CCCS, VC Switch):
        # Draw output pair as the component, control pair as short wires
        # Terminals: 0=ctrl+, 1=ctrl-, 2=out+, 3=out-
        out_start = transform(*terminals[2])
        out_end = transform(*terminals[3])
        ctrl_start = transform(*terminals[0])
        ctrl_end = transform(*terminals[1])

        opts = []
        if include_ids:
            opts.append(f"l=${_escape_latex(comp.component_id)}$")
        if include_values and comp.value:
            opts.append(f"a={{{_escape_latex(comp.value)}}}")
        opt_str = ", ".join([tikz_name] + opts)

        lines.append(f"  \\draw {_coord(*out_start)} to[{opt_str}] {_coord(*out_end)};")
        lines.append(
            f"  \\draw[dashed] {_coord(*ctrl_start)} to[short] {_coord(*ctrl_end)};"
        )
        return

    # Standard 2-terminal bipole
    t0 = transform(*terminals[0])
    t1 = transform(*terminals[1])
    opts = [tikz_name]
    if include_ids:
        opts.append(f"l=${_escape_latex(comp.component_id)}$")
    if include_values and comp.value:
        opts.append(f"a={{{_escape_latex(comp.value)}}}")
    opt_str = ", ".join(opts)
    lines.append(f"  \\draw {_coord(*t0)} to[{opt_str}] {_coord(*t1)};")


def _emit_tripole(lines, comp, tikz_name, transform, include_ids):
    """Emit a \node[component] and terminal connection lines for a 3-terminal component."""
    cx, cy = transform(*comp.position)
    anchors = TRIPOLE_ANCHORS[comp.component_type]
    node_id = comp.component_id.replace(" ", "_")

    # Rotation: CircuiTikZ expects rotation in degrees (same convention)
    rotate_opt = ""
    if comp.rotation != 0:
        rotate_opt = f", rotate={comp.rotation}"
    xscale = ""
    if comp.flip_h:
        xscale = ", xscale=-1"

    label_opt = ""
    if include_ids:
        label_opt = f", label={{right:{comp.component_id}}}"

    lines.append(
        f"  \\node[{tikz_name}{rotate_opt}{xscale}{label_opt}] ({node_id}) at {_coord(cx, cy)} {{}};"
    )

    # Draw short wires from tripole anchors to terminal positions
    terminals = comp.get_terminal_positions()
    for i, anchor in enumerate(anchors):
        tx, ty = transform(*terminals[i])
        lines.append(f"  \\draw ({node_id}.{anchor}) -- {_coord(tx, ty)};")


def _emit_wires(wires, components, transform):
    r"""Emit \draw lines for wires, using waypoints for routing."""
    wire_lines = []
    for wire in wires:
        start_comp = components.get(wire.start_component_id)
        end_comp = components.get(wire.end_component_id)
        if not start_comp or not end_comp:
            continue

        start_terminals = start_comp.get_terminal_positions()
        end_terminals = end_comp.get_terminal_positions()
        if wire.start_terminal >= len(start_terminals) or wire.end_terminal >= len(
            end_terminals
        ):
            continue

        start_pos = transform(*start_terminals[wire.start_terminal])
        end_pos = transform(*end_terminals[wire.end_terminal])

        # Skip wires whose terminals are already connected by a bipole draw
        # (bipole components already draw between their own terminals)
        if start_comp is end_comp and start_comp.component_type in CIRCUITIKZ_BIPOLES:
            continue

        if wire.waypoints:
            points = [start_pos]
            for wp in wire.waypoints:
                points.append(transform(*wp))
            points.append(end_pos)
            segments = " -- ".join(_coord(*p) for p in points)
            wire_lines.append(f"  \\draw {segments};")
        else:
            wire_lines.append(f"  \\draw {_coord(*start_pos)} -- {_coord(*end_pos)};")

    return wire_lines


def _emit_net_labels(nodes, terminal_to_node, components, transform):
    """Emit TikZ node labels for custom net names."""
    label_lines = []
    for node in nodes:
        if not node.custom_label:
            continue

        # Find a representative terminal position for this node
        pos = _node_representative_position(node, components)
        if pos is None:
            continue

        tx, ty = transform(*pos)
        label = _escape_latex(node.custom_label)
        label_lines.append(f"  \\node[above] at {_coord(tx, ty)} {{{label}}};")
    return label_lines


def _node_representative_position(node, components):
    """Find a world-coordinate position for a node based on its first terminal."""
    for comp_id, term_idx in node.terminals:
        comp = components.get(comp_id)
        if comp is None:
            continue
        terminals = comp.get_terminal_positions()
        if term_idx < len(terminals):
            return terminals[term_idx]
    return None
